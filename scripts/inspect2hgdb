#!/usr/bin/env python3

"""
Convert Inspect database to hgdb
Most of the implementation comes from the LegUp source code. Modifications are made to
move to modern Python and MySQL connector
"""
import MySQLdb
from MySQLdb import Connect
import argparse
import os
import getpass
import hgdb

# some constants used by legup
MYSQL_DATABASE_NAME = "legupDebug"


def get_input_args():
    parser = argparse.ArgumentParser(os.path.basename(__file__), description="Convert Inspect database to hgdb")
    parser.add_argument("output", help="Output symbol table")
    parser.add_argument("-p", help="Use password", action="store_true")
    parser.add_argument("-u", help="User name", type=str, default="root", required=False)
    args = parser.parse_args()
    if args.p:
        password = getpass.getpass(f"MySQL password for {args.u}")
    else:
        password = "letmein"

    # get mysql connection here
    connection = Connect(host="localhost", user=args.u, password=password, database=MYSQL_DATABASE_NAME)
    return connection, args.output


class LegUpDatabase:
    # notice that legup database is flat, which fits perfectly well with the sqlite version
    # of the symbol table. we will translate the symbol table
    def __init__(self, connection: MySQLdb.connections.Connection):
        self.cursor = MySQLdb.cursors.Cursor(connection)
        # making sure there is only one design
        self.top_id = self.__get_design_top()
        self.scopes = {}
        self.instances = {}
        self.breakpoints = {}
        self.rtl_signals = {}
        self.variables = {}
        self.variable_link = {}

        # populate the information
        self.__get_scopes()
        self.__get_instances()
        self.__get_breakpoints()
        self.__get_rtl_vars()
        self.__get_variables()

    def __get_design_top(self):
        self.cursor.execute("SELECT id, name FROM Designs")
        res = self.cursor.fetchall()
        if len(res) == 0:
            raise RuntimeError("No design found")
        elif len(res) != 1:
            # design name selection currently not supported
            raise RuntimeError("More than one design found. Please specify design name")
        else:
            return res[0]

    def __get_scopes(self):
        # in LegUp they callit functions. we treat it as scopes
        self.cursor.execute("SELECT id, name FROM Function WHERE designId = ?", self.top_id)
        res = self.cursor.fetchall()
        for func_id, func_name in res:
            self.scopes[func_id] = func_name

    def __get_instances(self):
        self.cursor.execute("SELECT id, instanceNum, functionId FROM Instance WHERE designID = ?", self.top_id)
        res = self.cursor.fetchall()
        for instance_id, instance_num, func_id in res:
            self.instances[instance_id] = (instance_num, func_id)

    def __get_breakpoints(self):
        # the only breakpoints available is through IR instructions
        self.cursor.execute(
            "SELECT ir.id, functionId, startStateId, endStateId, filePath, lineNumber, columnNumber FROM "
            "IRInstr ir INNER JOIN `Function` f on f.id = ir.functionID WHERE f.designID = ?",
            self.top_id)
        res = self.cursor.fetchall()
        for ir_id, func_id, start_id, end_id, file, line, column in res:
            self.breakpoints[ir_id] = (func_id, start_id, end_id, file, line, column)

    def __get_rtl_vars(self):
        # reads out all the RTL signals
        self.cursor.execute("SELECT r.id, functionID, signalName "
                            "FROM RtlSignal r INNER JOIN `Function` f ON f.id = r.functionId WHERE f.designId = ?",
                            self.top_id)
        res = self.cursor.fetchall()
        for r_id, func_id, name in res:
            self.rtl_signals[r_id] = (func_id, name)

    def __get_variables(self):
        # get all the variables
        # notice that we ignore global variables right now
        self.cursor.execute("SELECT id, name, functionId, filePath, lineNumber FROM Variable WHERE designId = ?",
                            self.top_id)
        res = self.cursor.fetchall()
        for id, name, func_id, file, line in res:
            if func_id is not None:
                self.variables[id] = (name, func_id, file, line)

    def __get_variable_link(self):
        # get the linking between variable and rtl signals
        self.cursor.execute(
            "SELECT vss.id, IRInstrId, v.id, rtlSignalId FROM VariableSourceSignal vss "
            "INNER JOIN VariableSource vs on vss.VariableSourceId = vs.id "
            "INNER JOIN Variable v on v.id = vs.variableId WHERE v.designId = %s",
            self.top_id)
        res = self.cursor.fetchall()
        for vss_id, var_id, rtl_id in res:
            self.variable_link[vss_id] = (var_id, rtl_id)

    def convert(self, output):
        db = hgdb.DebugSymbolTable(output)


def main():
    connection, output_filename = get_input_args()
    legup_database = LegUpDatabase(connection)
    legup_database.convert(output_filename)


if __name__ == "__main__":
    main()
